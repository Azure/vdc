Class AzureResourceManagerDeploymentService: IDeploymentService {
 
    [string] $armResourceGroupDeploymentUri = "https://management.azure.com/subscriptions/{0}/resourcegroups/{1}/providers/Microsoft.Resources/deployments/{2}?api-version=2018-05-01";
    [string] $armSubscriptionDeploymentUri = "https://management.azure.com/subscriptions/{0}/providers/Microsoft.Resources/deployments/{1}?api-version=2019-05-01"
    [string] $armResourceGroupValidationUri = "https://management.azure.com/subscriptions/{0}/resourcegroups/{1}/providers/Microsoft.Resources/deployments/{2}/validate?api-version=2018-05-01";
    [string] $armSubscriptionValidationUri = "https://management.azure.com/subscriptions/{0}/providers/Microsoft.Resources/deployments/{1}/validate?api-version=2019-05-01"
    
    [bool] $isSubscriptionDeployment = $false;
 
    [hashtable] ExecuteDeployment([string] $tenantId, `
                        [string] $subscriptionId, `
                        [string] $resourceGroupName, `
                        [string] $deploymentTemplate, `
                        [string] $deploymentParameters, `
                        [string] $location) {
       
        # call arm deployment
        $deployment = `
            $this.InvokeARMOperation(
                $tenantId,
                $subscriptionId,
                $resourceGroupName,
                $deploymentTemplate,
                $deploymentParameters,
                $location,
                "deploy");
       
        # retrieve the state of the resource and return state and deployment id that is
        # generated by arm
        # if it fails, throw an exception
        $resourceState = `
            $this.RetrieveDeploymentData(
                $deployment.Id,
                $deployment.Name,
                $resourceGroupName,
                $subscriptionId,
                $this.isSubscriptionDeployment);
 
        $resourceState += @{
            TenantId = $tenantId
            SubscriptionId = $subscriptionId
            ResourceGroupName = $resourceGroupName
            DeploymentTemplate = ConvertFrom-Json $deploymentTemplate -Depth 100
            DeploymentParameters = ConvertFrom-Json $deploymentParameters -Depth 100
        }
 
        return $resourceState;
    }

    [void] ExecuteValidation([string] $tenantId, `
                            [string] $subscriptionId, `
                            [string] $resourceGroupName, `
                            [string] $deploymentTemplate, `
                            [string] $deploymentParameters, `
                            [string] $location) {

        # call arm validation
        $validation = `
            $this.InvokeARMOperation(
                $tenantId,
                $subscriptionId,
                $resourceGroupName,
                $deploymentTemplate,
                $deploymentParameters,
                $location,
                "validate");

        # Did the validation succeed?
        if($validation.error.code -eq "InvalidTemplateDeployment") {
            # Throw an exception and pass the exception message from the 
            # ARM validation
            Throw ("Validation failed with the error below: {0}" -f (ConvertTo-Json $validation -Depth 50));
        }
        else {
            Write-Host "Validation Passed";
        }
    }
 
    hidden [string] GenerateUniqueDeploymentName() {
        # generate a new guid
        return [Guid]::NewGuid();
    }
 
    hidden [object] InvokeARMOperation([string] $tenantId, `
                                        [string] $subscriptionId, `
                                        [string] $resourceGroupName, `
                                        [string] $deploymentTemplate, `
                                        [string] $deploymentParameters,
                                        [string] $location, `
                                        [string] $operation) {
        $deployment = $null;
        $parametersJson = "";
 
        # Check for invariant
        if([string]::IsNullOrEmpty($deploymentTemplate)) {
            throw "Deployment template contents cannot be empty";
        }
        else {
 
            # Let's check if we are in a subscription or
            # resource group level deployment by inspecting
            # the schema
 
            $deploymentTemplateJson = `
                ConvertFrom-Json $deploymentTemplate `
                    -AsHashtable `
                    -Depth 100;

            # Concatenating the strings, because
            # "$schema" will try to resolve to a
            # variable
            $schema = "$" + "schema";
            $requestBody = "";
            $this.isSubscriptionDeployment = `
                $false;

            # By default, the scope is assumed to be 
            # resource group unless template schema 
            # contains the schema for subscription. 
            $scope = "resource-group";

            # Check for the scope of the operation
            if($deploymentTemplateJson.$schema.Contains("subscriptionDeploymentTemplate")) {
                # If template schema contains the schema for 
                # subscription, then the scope is set to 
                # subscription
                $scope = "subscription";
            }

            # Contruct the uri for the desired operation (deploy 
            # or validate) and for the desired scope (resource-group
            # or subscription)
            $uri = $this.ConstructUri(
                $subscriptionId,
                $resourceGroupName,
                $operation,
                $scope
            );
            
            # Prepare the request body for the REST API
            $requestBody = $this.PrepareRequestBodyForArm(
                $deploymentTemplate,
                $deploymentParameters,
                $location,
                $scope
            );
           
            # Get Access Token
            $accessToken = $this.GetAccessToken();
   
            # header will need the access token of the sp or user performing the deployment
            $headers = @{
                "authorization" = "Bearer $accessToken";
            }

            # Switch REST Verb based on operation type
            if($operation -eq "deploy") {
                $method = "Put";
            }
            else {
                $method = "Post";
            }
            
            try
            {  
                Write-Debug "Invoking ARM REST API with Uri: $uri";
                Write-Debug "Request Body: $(ConvertTo-Json $requestBody -Depth 50)";

                # Call REST API to start the deployment
                $deployment = `
                    Invoke-RestMethod `
                        -Method $method `
                        -Uri $uri `
                        -Body $requestBody `
                        -Headers $headers `
                        -ContentType "application/json";

                Write-Debug "Result of ARM Invocation is: $(ConvertTo-Json $deployment -Depth 50)";
 
                # wait for arm deployment
                if($deployment.Id -ne $null `
                    -and $operation -eq "deploy") {
                    # if the $deployment object's id is not null, then wait for the deployment to continue
                    # at this step, the REST call was accepted and being processed. The process can be tracked
                    # through the deployment object's id provided.
                    # Only two failures can result:
                    # 1. Template / Parameters Validation failure
                    # 2. Deployment failure
                    $this.WaitForDeploymentToComplete(
                        $deployment,
                        $this.isSubscriptionDeployment);
                }
                return $deployment;
            }
            catch {
                # For deploy operation, the error is due malformed or incorrect inputs
                if($operation -eq "deploy") {
                    Write-Host "An Exception Occurred While Invoking the Deployment. Please see the error below:";
                    Write-Host $_.ErrorDetails.Message;
                    throw $_.ErrorDetails.Message;
                }
                # For validate operation, the error is due to validation failure
                else {
                    return $_;
                }
            }
        }
    }
    
    hidden [string] PrepareRequestBodyForArm([string] $deploymentTemplate, `
                                                [string] $deploymentParameters, `
                                                [string] $location, `
                                                [string] $scope) {
        
        # Let's check if we are in a subscription or
        # resource group level deployment by inspecting
        # the schema
        $deploymentTemplateJson = `
            ConvertFrom-Json $deploymentTemplate `
                -AsHashtable `
                -Depth 100;
        # Concatenating the strings, because
        # "$schema" will try to resolve to a
        # variable
        $schema = "$" + "schema";
        $requestBody = "";
        $this.isSubscriptionDeployment = `
            $false;

        # generate a random guid to be used as deployment name
        $uniqueDeploymentName = `
            $this.GenerateUniqueDeploymentName();

        # Let's analyze the deployment parameters
        # if there's a schema, remove it

        if($deploymentParameters) {
            # if the parameters json contains $schema, etc as the first level properties,
            # we traverse one level down to retrieve only the parameters property of parent
            # and use the parameters object for deployment
            $parametersJson = `
                ConvertFrom-Json $deploymentParameters `
                    -AsHashtable;

            # falsy
            if($parametersJson.parameters) {
                $deploymentParameters = `
                    ConvertTo-Json $parametersJson.parameters `
                        -Compress `
                        -Depth 50;
            }
        }

        # Subscription level deployment
        if($scope -eq "subscription") {
                    
            $this.isSubscriptionDeployment = `
                $true;
            # prepare the REST Call's body content format
            $requestBody = "{
                'location': '$location',
                'properties': {
                    'mode': 'Incremental',
                    'template': $deploymentTemplate,
                    'parameters': $deploymentParameters
                }
            }";
        }
        else {
            # prepare the REST Call's body content format
            $requestBody = "{
                'properties': {
                    'mode': 'Incremental',
                    'template': $deploymentTemplate,
                    'parameters': $deploymentParameters
                }
            }";
        }

        return $requestBody;
    }

    hidden [string] ConstructUri([string] $subscriptionId, `
                                    [string] $resourceGroupName, `
                                    [string] $operation, `
                                    [string] $scope) {

        $uniqueDeploymentName = $this.GenerateUniqueDeploymentName();

        $uri = '';

        Write-Debug "Operation scope: $scope; Operation: $operation";

        # Subscription level deployment
        if($scope -eq "subscription") {
                    
            $this.isSubscriptionDeployment = `
                $true;

            if($operation -eq "deploy") {
                $uri = $this.armSubscriptionDeploymentUri;
            }
            else {
                $uri = $this.armSubscriptionValidationUri;
            }

            # construct the uri using the format for armSubscriptionDeploymentUri
            $uri = `
                $uri `
                    -f $subscriptionId, `
                    $uniqueDeploymentName;
        }
        else {

            if($operation -eq "deploy") {
                $uri = $this.armResourceGroupDeploymentUri;
            }
            else {
                $uri = $this.armResourceGroupValidationUri;
            }

            # construct the uri using the format for armResourceGroupDeploymentUri
            $uri = `
                $uri `
                    -f $subscriptionId, `
                    $resourceGroupName, `
                    $uniqueDeploymentName;
        }

        Write-Debug "Uri for deployment / validation operation: $uri";

        return $uri;
    }

    hidden [string] GetAccessToken() {

        # will need to perform Login-AzAccount from the terminal
        $context = Get-AzContext;
        $tokenCache = $context.TokenCache;
        $cacheItems = $tokenCache.ReadItems();
        $accessToken = '';
        $cacheItems | ForEach-Object {
            # Cache Items object's TenantId is null when run in
            # an AzDO Agent
            if ($_.TenantId `
                -and $_.TenantId -eq $tenantId `
                -and $_.ExpiresOn -gt (Get-Date)) {
                $accessToken = $_.AccessToken;
            }
            elseif($_.ExpiresOn -gt (Get-Date)) {
                $accessToken = $_.AccessToken;
            }
        }
        return $accessToken;
    }
 
    hidden [void] WaitForDeploymentToComplete([object] $deployment,
                                              [bool] $isSubscriptionDeployment) {
       
        $currentDeployment = $null;
        # loop until the deployment succeeds or fails
        $wait = 6;
        $loop = 0;
        $phase = 1;
        do {
            $loop++;
            Write-Host "Loop #: $loop";
            # Increment the phase number after
            # 10 loops
            if($loop%10 -eq 0) {
                Write-Host "Wait phase: $phase, complete";
                # Phase complete
                # new phase:
                $phase += 1;

                # let's increate the wait time
                $wait = ($wait * 2);
                
                Write-Host "Moving to next wait phase: $phase";
                Write-Host "New wait time: $wait seconds";
            }
            Write-Host "Waiting for deployment: $($deployment.Name) to complete. Will check in $wait seconds.";
            Start-Sleep -s $wait;
            
            # Get-AzResourceGroupDeployment will only return minimal details about the deployment
            # This includes the ProvisioningState and DeploymentId
            if ($isSubscriptionDeployment) {
                $currentDeployment = `
                    Get-AzDeployment `
                        -Id $deployment.Id;
            }
            else {
                $currentDeployment = `
                    Get-AzResourceGroupDeployment `
                        -Id $deployment.Id;
            }
        }
        while (@("Running", "Accepted") -match $currentDeployment.ProvisioningState)
   
        if (($currentDeployment.ProvisioningState -eq "Failed") -or `
            ($currentDeployment.ProvisioningState -eq "Canceled")) {
            # If the deployment fails, get the deployment details again.
            # But this time, call Get-AzResourceGroupDeploymentOperation, to get the error information which is
            # not available through the Get-AzResourceGroupDeployment AzureRm Cmdlet return object
            $allDeploymentDetails = Get-AzResourceGroupDeploymentOperation -ResourceGroupName $currentDeployment.ResourceGroupName -DeploymentName $currentDeployment.DeploymentName;
            $failedDeploymentDetails = $allDeploymentDetails | ? { $_.Properties.ProvisioningState -eq "Failed" }
            $errorDetails = " $($currentDeployment.DeploymentName) has failed."
            $errorDetails = $this.GetErrorMessage($failedDeploymentDetails);
            Throw $errorDetails;
        }
    }
 
    hidden [string] GetErrorMessage([object] $deploymentDetails) {
 
        $errorDetails = $null;
        # Iterate through all the deployments to retrieve the errors from deployments that have failed
        for($index=0;$index -lt $deploymentDetails.Count; $index++)
        {
            $errorDetail = $deploymentDetails[$index].Properties;
            $message = $errorDetail.statusMessage;
            # Loop until details is not found. If the property "details" is not found, then we have hit the object with the message to retrieve.
            $continueTraversingErrorObject = $true;
            while($continueTraversingErrorObject -eq $true) {
                # Iterate until you find an object that does not contain details property of type array.
                # If not found, try to parse the message into a Json.
                # If you cannot parse the message into a Json, that is the innermost exception we are looking for.
                if($message.PSObject.Properties.Name -match "details"){
                    $message = $message.details[0];
                }
                elseif($message.PSObject.Properties.Name -match "error"){
                    $message = $message.error;
                }
                else {
                    $continueTraversingErrorObject = $this.IsMessageAValidJson([ref]$message);
                }
            }
            # Double line breaks are for formatting purpose only
            $errorDetails += "`r`n`r`n";
            $errorDetails += "----------------------------------------------------------------------";
            $errorDetails += "`r`n`r`n";
            $errorDetails += "$($message.message)";
        }
        return $errorDetails;
    }
 
    hidden [hashtable] RetrieveDeploymentData([string] $deploymentId,
                                              [string] $deploymentName,
                                              [string] $resourceGroupName,
                                              [string] $subscriptionId,
                                              [bool] $isSubscriptionDeployment) {
 
        # hashtable to store the deployment id and state
        # to be returned
        $dataToReturn = @{
            DeploymentId = $null
            DeploymentName = $null
            ResourceStates = $null
            ResourceIds = $null
            DeploymentOutputs = $null
        };
 
        # set the deployment id value in the data to return
        $dataToReturn.DeploymentId = $deploymentId;
        $dataToReturn.DeploymentName = $deploymentName;
       
        $resourceIds = @();
 
        if ($isSubscriptionDeployment) {
            # Let's get all resource Ids created in a given
            # deployment
            Get-AzDeploymentOperation `
                -DeploymentName $deploymentName `
            | Select TargetResource `
            | ForEach-Object {
                $resourceIds += $_.TargetResource;
            }
        }
        else {
            # Let's get all resource Ids created in a given
            # deployment
            Get-AzResourceGroupDeploymentOperation `
                -Name $deploymentName `
                -ResourceGroupName $resourceGroupName `
                -SubscriptionId $subscriptionId `
            | Select Properties `
            | ForEach-Object {
                $resourceIds += $_.properties.targetResource.id;
            }
        }
 
        # Remove any duplicate ids
        $resourceIds = $resourceIds | Select -Unique
 
        # Convert to JSON resourceIds array.
        $dataToReturn.ResourceIds = $resourceIds;
 
        $resourceStates = @();
 
        # Let's use Azure Resource Graph to retrieve the
        # latest resource state
        $resourceIds | ForEach-Object {
            $latestState = `
                Search-AzGraph -Query "where id == '$_'";
           
            if($latestState) {
                # Let's initialize a new object
                $resourceState = @{
                    ResourceId = $null
                    State = $null
                };

                $resourceState.ResourceId = $_;
                # Convert to JSON latestState object
                $resourceState.State = $latestState;
 
                $resourceStates += $resourceState;
            }
        }
       
        $dataToReturn.ResourceStates = $resourceStates;
       
        # Let's retrieve deployment outputs
        $resourceGroupInformation = `
            Get-AzResourceGroupDeployment `
                -Id $deploymentId;
       
        $dataToReturn.DeploymentOutputs = `
            $resourceGroupInformation.Outputs;
       
        return $dataToReturn;
    }
 
    hidden [bool] IsMessageAValidJson($message) {
        try {
            $Message.Value = ConvertFrom-Json $Message.Value.message -ErrorAction Stop;
            $validJson = $true;
        } catch {
            $validJson = $false;
        }
        return $validJson;
    }
 
    [void] CreateResourceGroup([string] $resourceGroupName,
                               [string] $location) {
        try {
            New-AzResourceGroup `
                -Name $resourceGroupName `
                -Location $location -Force;
        }
        catch {
            Write-Host "An error ocurred while running CreateResourceGroup";
            Write-Host $_;
            throw $_;
        }
    }

    [void] SetSubscriptionContext([guid] $subscriptionId,
                                  [guid] $tenantId) {
        try {
            Select-AzSubscription `
                -Subscription $subscriptionId `
                -Tenant $tenantId;
        }
        catch {
            Write-Host "An error ocurred while running SetSubscriptionContext";
            Write-Host $_;
            throw $_;
        }
    }
}